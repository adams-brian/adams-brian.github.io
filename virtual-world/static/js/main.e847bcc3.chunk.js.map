{"version":3,"sources":["Components/Map.jsx","App.js","serviceWorker.js","index.js"],"names":["extend","FlyControls","Polygon","props","data","triangles","vertices","normal","vCount","length","normals","colors","i","push","bufferGeometry","THREE","setIndex","setAttribute","mesh","useRef","ref","geometry","attach","vertexColors","side","Building","ground","map","g","key","id","wall","w","roof","r","StatusUpdater","camera","useThree","div","cameraData","worldDirection","useFrame","getWorldDirection","current","newCameraData","position","toArray","v","toFixed","reduce","acc","c","innerHTML","slice","join","CameraControls","domElement","gl","lookAt","controls","state","delta","update","args","autoForward","dragToLook","movementSpeed","rollSpeed","Map","statusDiv","className","up","far","intensity","decay","color","buildings","b","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.e847bcc3.chunk.js","sourcesContent":["import React, { useRef } from 'react';\nimport { Canvas, extend, useFrame, useThree } from 'react-three-fiber';\nimport * as THREE from 'three';\nimport buildings from '../data/buildings.json';\nimport * as earcut from 'earcut';\nimport { FlyControls } from 'three/examples/jsm/controls/FlyControls';\nimport './Map.css';\n\nextend({ FlyControls });\n\nconst chunkArray = (arr, size) => \n  arr.reduce((acc, c, i) => {\n    if (i % size)\n      acc[Math.floor(i / size)].push(c);\n    else\n      acc.push([c]);\n    return acc;\n  }, []);\n\nconst SmartPolygon = ({ polygon }) => {\n  const origin = new THREE.Vector3(...polygon[1]);\n  const p1 = new THREE.Vector3(...polygon[0]);\n  const p2 = new THREE.Vector3(...polygon[2]);\n\n  const v1 = new THREE.Vector3().copy(p1).sub(origin);\n  const v2 = new THREE.Vector3().copy(p2).sub(origin);\n\n  const n = new THREE.Vector3().copy(v1).cross(v2).normalize();\n  const x = new THREE.Vector3().copy(v1).normalize();\n  const y = new THREE.Vector3().copy(x).cross(n).normalize();\n\n  const projected = polygon.map(p => new THREE.Vector3(...p)).map(p => [\n    p.dot(x),\n    p.dot(y)\n  ]);\n\n  const data = earcut.flatten([projected]);\n  const triangles = earcut(data.vertices, data.holes, data.dimensions);\n  if (triangles.length === 0) console.log('empty triangle polygon', polygon);\n  const geometry = new THREE.Geometry();\n  polygon.forEach(p => geometry.vertices.push(new THREE.Vector3(...p)));\n  chunkArray(triangles, 3).forEach(t => geometry.faces.push(new THREE.Face3(...t)));\n  geometry.computeFaceNormals();\n  geometry.computeVertexNormals();\n  \n  const mesh = useRef();\n  return (\n    <mesh\n      ref={mesh}\n      geometry={geometry}\n    >\n      <meshPhysicalMaterial\n        attach=\"material\"\n        color='#888888'\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n\nconst Polygon = props => {\n  const { triangles, vertices, normal } = props.data;\n  const vCount = vertices.length / 3;\n  const normals = [];\n  const colors = [];\n  for (let i = 0; i < vCount; i++) {\n    normals.push(...normal);\n    colors.push(0.3, 0.3, 0.3);\n  }\n  const bufferGeometry = new THREE.BufferGeometry();\n  bufferGeometry.setIndex(triangles);\n  bufferGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n  bufferGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n  bufferGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n  const mesh = useRef();\n  return (\n    <mesh\n      ref={mesh}\n      geometry={bufferGeometry}\n    >\n      <meshPhongMaterial\n        attach=\"material\"\n        vertexColors={true}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n\nconst Building = props => {\n  const { data } = props;\n  return (\n    <>\n      {data.ground.map(g => (<Polygon key={g.id} data={g}/>))}\n      {data.wall.map(w => (<Polygon key={w.id} data={w}/>))}\n      {data.roof.map(r => (<Polygon key={r.id} data={r}/>))}\n    </>\n  )\n\n};\n\nconst StatusUpdater = props => {\n  const { camera } = useThree();\n  const { div } = props;\n  const cameraData = useRef([0, 0, 0, 0, 0, 0]);\n  const worldDirection = useRef(new THREE.Vector3());\n  useFrame(() => {\n    camera.getWorldDirection(worldDirection.current);\n    const newCameraData = [...camera.position.toArray().map(v => v.toFixed(3)),\n      ...worldDirection.current.toArray().map(v => v.toFixed(3))];\n    if(!cameraData.current.reduce((acc, c, i) => acc && c === newCameraData[i], true)) {\n      div.current.innerHTML = 'Camera <br>Position: ( '\n      + newCameraData.slice(0, 3).join(' ') + ' )<br>Direction: ( ' +\n      newCameraData.slice(3).join(' ') + ' )';\n    }\n    cameraData.current = newCameraData;\n  });\n  return null;\n}\n\nconst CameraControls = () => {\n  const {\n    camera,\n    gl: { domElement },\n  } = useThree();\n  camera.lookAt(new THREE.Vector3(200, 0, 400));\n  const controls = useRef();\n  useFrame((state, delta) => controls.current.update(delta));\n  return (\n    <flyControls\n      ref={controls}\n      args={[camera, domElement]}\n      autoForward={false}\n      dragToLook={true}\n      movementSpeed={200}\n      rollSpeed={0.3}\n    />\n  );\n};\n\nexport const Map = () => {\n  const statusDiv = useRef(null);\n  return (\n    <>\n      <div className=\"status\" ref={statusDiv}>loading...</div>\n      <Canvas camera={{\n        up: new THREE.Vector3(0, 0, 1),\n        position: new THREE.Vector3(160, 1900, 900),\n        far: 5000 }}>\n        <StatusUpdater div={statusDiv}/>\n        <CameraControls/>\n        <ambientLight intensity='0.3' />\n        <pointLight position={[0, 0, 1000]} intensity='2' decay='2' />\n        <pointLight position={[-1000, -1000, 1000]} color='purple' intensity='1' decay='2' />\n        <pointLight position={[1000, -1000, 1000]} color='blue' intensity='1' decay='2' />\n        <pointLight position={[-1000, 1000, 1000]} color='cyan' intensity='1' decay='2' />\n        <axesHelper args={100}/>\n        { buildings.map(b => <Building key={b.id} data={b} />) }\n      </Canvas>\n    </>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport { Map } from './Components/Map';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Map/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}